# Example usage:
# python occlusion.py 
#   --image_dir=/path/to/image
#   --graph=retrained_graph.pb
#   --labels=retrained_labels.txt

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import argparse
import sys
import os
import matplotlib.pyplot as plt
import numpy as np
from math import *
from scipy.misc import imread
from scipy.misc import imsave
from cStringIO import StringIO
from PIL import Image
from glob import glob
import random
import tensorflow as tf
import time

os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"

parser = argparse.ArgumentParser()
parser.add_argument(
    "--image_dir", required=True, type=str, help="Absolute path to image directory.")
parser.add_argument(
    "--num_top_predictions",
    type=int,
    default=5,
    help="Display this many predictions.")
parser.add_argument(
    "--graph",
    required=True,
    type=str,
    help="Absolute path to graph file (.pb)")
parser.add_argument(
    "--labels",
    required=True,
    type=str,
    help="Absolute path to labels file (.txt)")
parser.add_argument(
    "--output_layer",
    type=str,
    default="final_result:0",
    help="Name of the result operation")
parser.add_argument(
    "--input_layer",
    type=str,
    default="DecodeJpeg/contents:0",
    help="Name of the input operation")
parser.add_argument(
    "--roi_size",
    type=int,
    default=32,
    help="Size, in pixels, of the occluding filter")
parser.add_argument(
    "--stride",
    type=int,
    default=32,
    help="Length, in pixels, of the stride of the occluding filter")

# Return batch of images with an occlusion square systematically moved across and saved
def createOcclusion(im,roi_size,stride_size):     
    iters = floor((512-roi_size+1)/stride_size)
    iters = int(iters)
    batch_size = iters**2
    batch = np.ndarray([batch_size], dtype=object)
    i = 0
    for r in range(0,iters):
        for c in range(0,iters):
            imOc = np.copy(im)
            imOc[r*stride_size:r*stride_size+roi_size-1,c*stride_size:c*stride_size+roi_size-1] = 150
            occlusion_image_stream = StringIO()
            imsave(occlusion_image_stream, imOc, "jpeg")           
            batch[i] = occlusion_image_stream.getvalue()
            occlusion_image_stream.close()            
            i = i + 1
    return batch
    # return 0

# Read in image to be classified
def load_image(filename):
  return imread(filename), tf.gfile.FastGFile(filename, "rb").read()

# Read in labels
def load_labels(filename):
  return [line.rstrip() for line in tf.gfile.GFile(filename)]

# Load saved graph
def load_graph(filename):
  with tf.gfile.FastGFile(filename, "rb") as f:
    graph_def = tf.GraphDef()
    graph_def.ParseFromString(f.read())
    tf.import_graph_def(graph_def, name="")

def run_graph(image_data, occlusion_array, labels, input_layer_name, output_layer_name,
              num_top_predictions, filename):
  with tf.Session() as sess:
    # Feed the image_data as input to the graph.
    #   predictions  will contain a two-dimensional array, where one
    #   dimension represents the input image count, and the other has
    #   predictions per class
    since = time.time()
    occlusion_array_string = StringIO()
    imsave(occlusion_array_string, occlusion_array, "jpeg")
    softmax_tensor = sess.graph.get_tensor_by_name(output_layer_name)
    predictions, = sess.run(softmax_tensor, {input_layer_name: occlusion_array_string.getvalue()})
    occlusion_array_string.close()

    # Sort to show labels in order of confidence
    top_k = predictions.argsort()[-num_top_predictions:][::-1]
    
    roi_size = FLAGS.roi_size
    stride_size = FLAGS.stride

    im_batch = createOcclusion(occlusion_array,roi_size,stride_size)

    # initialize array (0, num_classes)
    outbatch = tf.zeros((0, 2))
    for i in range(im_batch.shape[0]):
      intermediate = sess.run(softmax_tensor, {input_layer_name: im_batch[i]})
      outbatch = tf.concat([outbatch, intermediate], axis = 0)

   
    # Get predicted probabilities from occlusion batch 
    predicted_prob = np.empty(im_batch.shape[0], dtype=object)
    for i in range(im_batch.shape[0]):
      predicted_prob[i] = tf.nn.softmax(outbatch[i])[top_k[0]]

    iters = int(floor((512-roi_size+1)/stride_size))

    occlusion_map = np.ndarray([iters, iters], dtype=float)

    i = 0
    for r in range(0,iters):
      for c in range(0,iters):
        # Plots probability function generated by occlusion
        occlusion_map[r,c] = 1 - sess.run(predicted_prob[i])
        i = i+1

    plt.matshow(occlusion_map, interpolation = "lanczos", cmap = "magma")

    map_filename = "/home/daniel/Documents/maps/{}.png".format(filename.split("/")[-1].split(".")[0])
    plt.savefig(map_filename, bbox_inches = "tight", pad_inches = 0)
    plt.axis("off")
    #plt.show()
    im1 = Image.open(filename)
    im1 = im1.convert("RGB")
    im1 = im1.resize((512,512))
    im2 = Image.open(map_filename)
    width, height = im2.size
    im2 = im2.convert("RGB")
    im2 = im2.crop((20,25,width-5,height-5))
    im2 = im2.resize((512,512))
    im3 = Image.blend(im1, im2, 0.4)
    #im3.show()
    im2.close()
    output_path = os.path.expanduser("~/Desktop/{}".format("Occlusion"))
    if not os.path.exists(output_path):
      os.makedirs(output_path)
    output_path += "/{}".format(filename.split("/")[-1])
    im3.save(output_path)
    im3.close()
    elapsed = time.time() - since
    print("Finished in {} minutes and {} seconds".format(elapsed // 60, elapsed % 60))
    plt.close("all")
    return 0

def main(argv):
  if argv[1:]:
    raise ValueError("Unused Command Line Args: %s" % argv[1:])

  if not tf.gfile.Exists(FLAGS.labels):
    tf.logging.fatal("labels file does not exist %s", FLAGS.labels)

  if not tf.gfile.Exists(FLAGS.graph):
    tf.logging.fatal("graph file does not exist %s", FLAGS.graph)

  # load graph, which is stored in the default session
  load_graph(FLAGS.graph)

  occlusion_array, image_data = load_image(FLAGS.image_dir)

  # load labels
  labels = load_labels(FLAGS.labels)

  run_graph(image_data, occlusion_array, labels, FLAGS.input_layer, FLAGS.output_layer,
            FLAGS.num_top_predictions, FLAGS.image_dir)

if __name__ == "__main__":
  FLAGS, unparsed = parser.parse_known_args()
  tf.app.run(main=main, argv=sys.argv[:1]+unparsed)
